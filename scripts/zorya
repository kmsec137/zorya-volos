#!/usr/bin/env bash
##############################################################################
#                             Z O R Y A  wrapper
#   Interactive by default – but any missing info can be supplied via flags.
##############################################################################

RESET="\033[0m"; BOLD="\033[1m"; CYAN="\033[36m"; GREEN="\033[32m"

print_banner() {
  cat << 'EOF'
███████╗ ██████╗ ██████╗ ██╗   ██╗ █████╗ 
╚══███╔╝██╔═══██╗██╔══██╗╚██╗ ██╔╝██╔══██╗
  ███╔╝ ██║   ██║██████╔╝ ╚████╔╝ ███████║
 ███╔╝  ██║   ██║██╔══██╗  ╚██╔╝  ██╔══██║
███████╗╚██████╔╝██║  ██║   ██║   ██║  ██║
╚══════╝ ╚═════╝ ╚═╝  ╚═╝   ╚═╝   ╚═╝  ╚═╝
EOF
  echo -e "    ${CYAN}${BOLD}Next Generation Concolic Analysis${RESET}"
}
divider() { echo -e "${CYAN}*************************************************************************************${RESET}"; }

##############################################################################
#                         INSTALL-TIME PATHS
##############################################################################
ZORYA_DIR="__ZORYA_DIR__"
[[ "$ZORYA_DIR" == "__ZORYA_DIR__" ]] && { echo "Reinstall required"; exit 1; }

PCODE_GENERATOR_DIR="$ZORYA_DIR/external/pcode-generator"
INIT_DATA_DIR="$ZORYA_DIR/results/initialization_data"
[[ ! -d "$PCODE_GENERATOR_DIR" ]] && { echo "Missing pcode-generator – run make all"; exit 1; }
mkdir -p "$INIT_DATA_DIR"

##############################################################################
#                         HELPER FUNCTIONS
##############################################################################

# Get the binary entry point using readelf
get_entry_point() {
  readelf -h "$1" | awk '/Entry point address:/ {print $NF}'
}

# Try to find the Go or C-style main symbol address
get_main_addr() {
  nm "$1" | awk '
    / main.main$/     {print "0x"$1; found=1; exit}
    / main$/          {m="0x"$1}
    END { if (!found && m) print m }'
}

##############################################################################
#                         BASIC ARG PARSER
##############################################################################

# Binary must be provided as the first argument
if [[ -z "$1" || "$1" == -* ]]; then
  echo -e "${CYAN}${BOLD}Zorya - Next Generation Concolic Analysis${RESET}"
  echo ""
  echo -e "${BOLD}Usage:${RESET}"
  echo -e "  zorya ${GREEN}<binary>${RESET} [options]"
  echo ""
  echo -e "${BOLD}Options:${RESET}"
  echo -e "  ${GREEN}--lang${RESET} <go|c|c++>              Source language of the binary"
  echo -e "  ${GREEN}--compiler${RESET} <tinygo|gc>         Go compiler used (required for Go binaries)"
  echo -e "  ${GREEN}--mode${RESET} <start|main|function|custom> [addr]"
  echo -e "                                  Analysis starting point"
  echo -e "  ${GREEN}--thread-scheduling${RESET} <all-threads|main-only>"
  echo -e "                                  Thread scheduling strategy (Go GC only)"
  echo -e "  ${GREEN}--arg${RESET} <args...>               Binary arguments"
  echo -e "  ${GREEN}--negate-path-exploration${RESET}     Enable path negation (default: yes)"
  echo -e "  ${GREEN}--no-negate-path-exploration${RESET}  Disable path negation"
  echo ""
  echo -e "${BOLD}Examples:${RESET}"
  echo -e "  zorya ./myprogram --lang go --compiler tinygo --mode main --arg \"input\""
  echo -e "  zorya /path/to/binary --lang c --mode function 0x401000"
  echo ""
  exit 1
fi

BIN_PATH_ORIGINAL="$1"; shift || true

# Check if binary exists first
if [[ ! -f "$BIN_PATH_ORIGINAL" ]]; then
  echo "Error: Binary file not found: $BIN_PATH_ORIGINAL"
  exit 1
fi

# Convert to absolute path so it works even after we cd to different directories
BIN_PATH="$(cd "$(dirname "$BIN_PATH_ORIGINAL")" && pwd)/$(basename "$BIN_PATH_ORIGINAL")"

# Initialize variables
SOURCE_LANG=""
COMPILER=""
MODE=""
ADDR=""
ARGS="none"
NEGATE_PATH_FLAG=""
THREAD_SCHEDULING=""

# Argument parsing loop
while [[ $# -gt 0 ]]; do
  case "$1" in
    --lang)
      SOURCE_LANG="$2"; shift 2 ;;
    --compiler)
      COMPILER="$2"; shift 2 ;;
    --thread-scheduling)
      THREAD_SCHEDULING="$2"; shift 2 ;;
    --mode)
      MODE="$2"; shift 2
      # Accept an address for *any* mode (main/function/custom)
      if [[ $# -gt 0 && "$1" != "--"* && "$1" =~ ^0x[0-9a-fA-F]+$ ]]; then
        ADDR="$1"; shift
      fi
      ;;
    --negate-path-exploration|--negate)
      NEGATE_PATH_FLAG="true"; shift ;;
    --no-negate-path-exploration|--no-negate)
      NEGATE_PATH_FLAG="false"; shift ;;
    --arg)
      shift
      while [[ $# -gt 0 ]]; do
        if [[ "$1" == --negate* ]]; then
          NEGATE_PATH_FLAG="true"
          shift
          break
        elif [[ "$1" == --no-negate* ]]; then
          NEGATE_PATH_FLAG="false"
          shift
          break
        else
          if [[ "$ARGS" == "none" ]]; then
            ARGS="$1"
          else
            ARGS="$ARGS $1"
          fi
          shift
        fi
      done
      ;;
    --help|-h)
      echo -e "${CYAN}${BOLD}Zorya - Next Generation Concolic Analysis${RESET}"
      echo ""
      echo -e "${BOLD}Usage:${RESET}"
      echo -e "  zorya ${GREEN}<binary>${RESET} [options]"
      echo ""
      echo -e "${BOLD}Options:${RESET}"
      echo -e "  ${GREEN}--lang${RESET} <go|c|c++>              Source language of the binary"
      echo -e "  ${GREEN}--compiler${RESET} <tinygo|gc>         Go compiler used (required for Go binaries)"
      echo -e "  ${GREEN}--mode${RESET} <start|main|function|custom> [addr]"
      echo -e "                                  Analysis starting point"
      echo -e "  ${GREEN}--thread-scheduling${RESET} <all-threads|main-only>"
      echo -e "                                  Thread scheduling strategy (Go GC only)"
      echo -e "  ${GREEN}--arg${RESET} <args...>               Binary arguments"
      echo -e "  ${GREEN}--negate-path-exploration${RESET}     Enable path negation (default: yes)"
      echo -e "  ${GREEN}--no-negate-path-exploration${RESET}  Disable path negation"
      echo -e "  ${GREEN}--help${RESET}, ${GREEN}-h${RESET}                    Show this help message"
      echo ""
      echo -e "${BOLD}Examples:${RESET}"
      echo -e "  zorya ./myprogram --lang go --compiler tinygo --mode main --arg \"input\""
      echo -e "  zorya /path/to/binary --lang c --mode function 0x401000"
      echo -e "  zorya ../tests/crashme --lang go --compiler gc --mode main --arg \"test\" --negate"
      echo ""
      exit 0
      ;;
    *)
      echo "Unknown flag: $1"; exit 1 ;;
  esac
done

##############################################################################
#                        INTERACTIVE QUESTIONS (fallback)
##############################################################################

INTERACTIVE_MODE=false
[[ -z "$SOURCE_LANG" || -z "$MODE" || "$ARGS" == "none" || -z "$NEGATE_PATH_FLAG" ]] && INTERACTIVE_MODE=true
[[ "${SOURCE_LANG,,}" == "go" && -z "$COMPILER" ]] && INTERACTIVE_MODE=true

if [[ "$INTERACTIVE_MODE" == "true" ]]; then
  echo ""
  print_banner
else
  echo ""
  echo -e "${CYAN}${BOLD}ZORYA - Next Generation Concolic Analysis${RESET}"
fi

# 0. Language
if [[ -z "$SOURCE_LANG" ]]; then
  echo ""; echo "What is the source language of the binary? (go, c or c++)"
  read -rp "[go]: " SOURCE_LANG; SOURCE_LANG="${SOURCE_LANG:-go}"
fi; export SOURCE_LANG

# 0b. Go compiler (if applicable)
if [[ "${SOURCE_LANG,,}" == "go" && -z "$COMPILER" ]]; then
  echo ""; echo "Which Go compiler was used? (tinygo / gc)"
  read -rp "[tinygo]: " COMPILER; COMPILER="${COMPILER:-tinygo}"
fi; export COMPILER

# 0c. Thread scheduling for Go GC binaries
if [[ "${SOURCE_LANG,,}" == "go" && "${COMPILER,,}" == "gc" && -z "$THREAD_SCHEDULING" ]]; then
  echo ""; echo "Thread scheduling strategy for Go GC binary:"
  echo "  - all-threads: Explore multiple goroutines with cooperative scheduling at function calls (recommended for concurrency bugs)"
  echo "  - main-only: Only execute the main thread (faster, but may miss concurrency issues)"
  read -rp "[all-threads]: " THREAD_SCHEDULING; THREAD_SCHEDULING="${THREAD_SCHEDULING:-all-threads}"
fi; export THREAD_SCHEDULING
[[ "$INTERACTIVE_MODE" == "true" ]] && divider

ENTRY_POINT=$(get_entry_point "$BIN_PATH")

# 1. Mode
if [[ -z "$MODE" ]]; then
  echo ""; echo "Where to begin the analysis? (start / main / function / custom)"
  read -rp "[main]: " MODE; MODE="${MODE:-main}"
fi

# 2. Address selection
case "$MODE" in
  start)
    [[ -z "$ADDR" ]] && ADDR="$ENTRY_POINT"
    [[ "$INTERACTIVE_MODE" == "true" ]] && echo -e "${GREEN}Entry point: $ADDR${RESET}" ;;
  main)
    if [[ -z "$ADDR" ]]; then
      ADDR=$(get_main_addr "$BIN_PATH")
      [[ -z "$ADDR" ]] && { echo "Could not locate main"; exit 1; }
      [[ "$INTERACTIVE_MODE" == "true" ]] && echo -e "${GREEN}Main address (auto-detected): $ADDR${RESET}"
    else
      [[ "$INTERACTIVE_MODE" == "true" ]] && echo -e "${GREEN}Main address (user-supplied): $ADDR${RESET}"
    fi
    ;;
  function|custom)
    while [[ -z "$ADDR" ]]; do
      echo ""; read -rp "At what address should the analysis begin? (hex e.g. 0x123): " ADDR
      [[ "$ADDR" =~ ^0x[0-9a-fA-F]+$ || "$ADDR" =~ ^[0-9]+$ ]] || ADDR=""
    done ;;
  *)
    echo "Unknown mode: $MODE"; exit 1 ;;
esac
[[ "$INTERACTIVE_MODE" == "true" ]] && divider

# 3. Runtime arguments
if [[ "$ARGS" == "none" ]]; then
  echo ""; echo "Does the binary expect any arguments? (none / e.g., x y z)"
  read -rp "[none]: " ARGS; ARGS="${ARGS:-none}"
fi
[[ "$INTERACTIVE_MODE" == "true" ]] && divider

# 4. Negate path exploration
if [[ -z "$NEGATE_PATH_FLAG" ]]; then
  echo ""; echo "Do you want to activate the negating path execution to cover symbolically more paths?"
  read -rp "[Y/n]: " ENABLE_NEGATING; ENABLE_NEGATING="${ENABLE_NEGATING,,}"
  if [[ "$ENABLE_NEGATING" == "n" || "$ENABLE_NEGATING" == "no" ]]; then
    NEGATE_PATH_FLAG="false"
  else
    NEGATE_PATH_FLAG="true"
  fi
fi
[[ "$INTERACTIVE_MODE" == "true" ]] && divider

##############################################################################
#                        ENV EXPORTS & FINAL COMMAND
##############################################################################

export MODE ARGS START_POINT="$ADDR" ZORYA_DIR BIN_PATH NEGATE_PATH_FLAG="$NEGATE_PATH_FLAG"

# Build final command string (using original path for display, but actual execution uses absolute)
CMD="$ZORYA_DIR/zorya $BIN_PATH_ORIGINAL --mode $MODE"
[[ -n "$ADDR" ]] && CMD+=" $ADDR"
[[ -n "$SOURCE_LANG" ]] && CMD+=" --lang $SOURCE_LANG"
[[ -n "$COMPILER" ]] && CMD+=" --compiler $COMPILER"
[[ -n "$THREAD_SCHEDULING" ]] && CMD+=" --thread-scheduling $THREAD_SCHEDULING"
[[ "$ARGS" != "none" ]] && CMD+=" --arg \"$ARGS\""
[[ "$NEGATE_PATH_FLAG" == "true" ]] && CMD+=" --negate-path-exploration" || CMD+=" --no-negate-path-exploration"

echo "*************************************************************************************"
echo "Running command: $CMD"
echo ""

# Step 1: Pcode generation
cd "$PCODE_GENERATOR_DIR" || exit 1
RUSTFLAGS="--cap-lints=allow" cargo run --release "$BIN_PATH" --low-pcode

PCODE_FILE="$PCODE_GENERATOR_DIR/results/$(basename "$BIN_PATH")_low_pcode.txt"
[[ ! -f "$PCODE_FILE" ]] && { echo "Pcode generation failed."; exit 1; }

# Step 2: Generate dumps
echo ""; echo "Generating memory and CPU register dumps…"
chmod +x "$ZORYA_DIR/scripts/dump_memory.sh"
"$ZORYA_DIR/scripts/dump_memory.sh" "$BIN_PATH" "$ADDR" "$ENTRY_POINT" "$ARGS"

# Step 2.5: Extract and analyze VDSO
echo ""; echo "Extracting VDSO from process memory…"
chmod +x "$ZORYA_DIR/scripts/extract_vdso.sh"
"$ZORYA_DIR/scripts/extract_vdso.sh" "$BIN_PATH" "$ADDR" "$ARGS"

if [[ -f "$INIT_DATA_DIR/vdso/vdso.so" && -f "$INIT_DATA_DIR/vdso/vdso_base_addr.txt" ]]; then
  VDSO_BASE=$(cat "$INIT_DATA_DIR/vdso/vdso_base_addr.txt")
  echo ""; echo "Generating p-code for VDSO (base: $VDSO_BASE)…"
  chmod +x "$ZORYA_DIR/scripts/generate_vdso_pcode.sh"
  "$ZORYA_DIR/scripts/generate_vdso_pcode.sh" "$INIT_DATA_DIR/vdso/vdso.so" "$VDSO_BASE"
else
  echo "⚠ Warning: VDSO extraction failed, continuing without VDSO support"
fi

# Step 3: Run Zorya core
echo ""; 
echo "*********************************************************************************************"
echo "Completed the generation of memory and CPU register dumps, and the P-Code file of the binary."
echo "Launching Zorya now..."
echo "*********************************************************************************************"
echo ""

cd "$ZORYA_DIR" || exit 1
RUSTFLAGS="--cap-lints=allow" cargo run --release -- --write-args "$ARGS"
