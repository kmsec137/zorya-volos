<!--
SPDX-FileCopyrightText: 2025 Ledger https://www.ledger.com - INSTITUT MINES TELECOM

SPDX-License-Identifier: Apache-2.0
-->

# Vulnerability Detection in Zorya

Zorya detects memory safety vulnerabilities through **runtime checks** during concolic execution. These checks operate at the P-code level and work in both concrete execution and overlay paths.

## Detection Mechanisms

### 1. NULL Pointer Dereference

**Checked on**: Every `LOAD` and `STORE` operation  
**Location**: `src/concolic/executor.rs` (`handle_load`, `handle_store`)

```rust
if pointer_offset_concrete == 0 {
    println!("/!\\ Dereferencing NULL pointer detected, execution halted!");
    process::exit(1);
}
```

**When detected**:
- Reading from address `0x0` (NULL dereference read)
- Writing to address `0x0` (NULL dereference write)

**Works in**:
- Concrete execution (main path)
- Overlay execution (untaken paths)

---

### 2. Division by Zero

**Checked on**: Every `INT_DIV` and `INT_REM` operation  
**Location**: `src/concolic/executor.rs` (`handle_int_div`, `handle_int_rem`)

```rust
if denominator_concrete == 0 {
    println!("/!\\ Division by zero detected, execution halted!");
    process::exit(1);
}
```

**When detected**:
- Integer division with divisor = 0
- Modulo operation with divisor = 0

**Works in**:
- Concrete execution (main path)
- Overlay execution (untaken paths)

---

### 3. Dangling Pointer (Use-After-Free on Stack)

**Checked on**: Every `LOAD` and `STORE` operation  
**Location**: `src/concolic/executor.rs` (`handle_load`, `handle_store`, `check_dangling_pointer_access`)

**Mechanism**:

1. **Track stack frames**:
   - On `CALL`: Record function address + RSP (stack pointer on entry)
   - On `RETURN`: Mark frame as freed, record RSP on exit, add to freed frames queue

2. **Check memory accesses**:
   ```rust
   if let Some((func_addr, frame_rsp)) = self.check_dangling_pointer_access(address) {
       println!("/!\\ DANGLING POINTER detected at 0x{:x}!", address);
       process::exit(1);
   }
   ```

3. **Detection logic**:
   - For each freed frame, check if access address is in `[frame_low..frame_high]`
   - Verify current RSP is above freed frame (stack unwound = truly freed)
   - If both conditions met → **dangling pointer**

**When detected**:
- Accessing memory that belonged to a function's stack frame after that function returned
- Classic use-after-free bug on stack memory
- Common in unsafe code (C/C++/Rust/Go with `unsafe.Pointer`)

**Example flow**:
```
1. CALL parseSignature → Push frame (RSP=0x1000)
2. RETURN → Pop frame, mark as freed (RSP_exit=0x1008)
3. LOAD from 0x1004 → Address in freed range [0x1000..0x1008]
4. Current RSP=0x1010 > 0x1008 → Stack unwound
5. → DANGLING POINTER DETECTED!
```

**Works in**:
- Concrete execution (main path)
- Overlay execution (untaken paths): when overlay ends, overlay-created frames are removed from `freed_stack_frames` to prevent false positives


## Performance Considerations

- **NULL pointer checks**: O(1) comparison
- **Division by zero checks**: O(1) comparison
- **Dangling pointer checks**: O(10) - checks against last 10 freed frames
- **Memory overhead**: Minimal - only 10 frames tracked in freed queue


